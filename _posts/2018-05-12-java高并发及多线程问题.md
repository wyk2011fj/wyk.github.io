---
layout:         post
title:          java高并发及多线程问题
subtitle:       作为java多线程，高并发的笔记，持续更新...
card-image:     https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1526140987556&di=b86d007b9a490e5c99a0a155ae97de77&imgtype=0&src=http%3A%2F%2Fwww.cssxt.com%2Fuploadfile%2F2017%2F0824%2F20170824104515761.jpg
date:           2018-05-12 21:00:00
tags:           java
post-card-type: image
---

参考博文：https://blog.csdn.net/suifeng3051/article/details/52611310

最近在工作中碰到了部署的数据导入接口请求过于频繁引起的数据库死锁及阻塞问题，被DBA喷了几次后，终于解决了，不过也发现自己对这块确实还不是很熟，还是将查阅的信息记录下，以备后用。


## 1.Java内存模型

Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。

Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此Java1.5版本对其进行了重构，现在的Java8仍沿用了Java1.5的版本。

在并发编程领域，有两个关键问题：线程之间的通信和同步。

#### 线程之间的通信

线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内存和消息传递。

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。

#### 线程之间的同步

同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

#### JMM

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程用以读/写共享变量的副本。

![MacDown Screenshot](https://img-blog.csdn.net/20160921182337904)

所以，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：
1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 线程B到主内存中去读取线程A之前已更新过的共享变量。

在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区。

![MacDown Screenshot](https://img-blog.csdn.net/20160921182837697)

所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程。

一个本地变量如果是原始类型，那么它会被完全存储到栈区。 
一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。

对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区（拷贝），即使它们所属的对象在堆区。 
对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。（所以多个线程调用一个对象的成员变量线程不安全）

Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。*

两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。

volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的。*

同时读主内存，如多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象（即线程不安全）。

Final变量在并发当中，原理是通过禁止cpu的指令集重排序来保证对象的安全发布，防止对象引用被其他线程在对象被完全构造完成前拿到并使用。故final类型的成员变量的值，包括那些用final引用指向的collections的对象，是读线程安全而无需使用synchronization的。（与内存无关，不同原理）*

synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。*



## 2.
### 静态变量：线程非安全。
静态变量即类变量，位于方法区，为所有对象共享，共享一份内存，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。

