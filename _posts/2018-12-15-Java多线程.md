---
layout:         post
title:          Java多线程相关
subtitle:       常见多线程知识点整理
card-image:     https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1544886985001&di=6dabac2fd3dd7d2b0af391951190b93a&imgtype=0&src=http%3A%2F%2Fs1.51cto.com%2Foss%2F201802%2F27%2F164a32018df83046460958996918d890.jpg-wh_651x-s_1321967539.jpg
date:           2018-12-15 21:00:00
tags:           BigDataInterview
post-card-type: image
---

  无论是开dubbo接口、http接口，还是Java Web服务端开发，亦或者是各种中间件的开发；无并发，不Java，你们懂的；必须专门开一篇以示尊重，Java不息，更新不止。
  
#### 1.相关概念

    1.关键字 synchronized
    
      使用场景：
      
![MacDown Screenshot](/assets/images/2615789-08f16aeac7e0977d.png)

    原理：
    同步代码块：
      反编译可以看到monitorenter，monitorexit指令（相对于不加synchronized多出来）；
      原理：每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态，
           线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
           1、monitor的进入数为0，则该线程进入monitor，将进入数设置为1，该线程即为monitor的所有者。
           2、线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
           3、其他线程占用monitor，则该线程进入阻塞状态，直到monitor进入数为0，再尝试monitor所有权。  
           
           执行monitorexit的线程必须是objectref所对应的monitor的所有者。
           执行后，monitor进入数减1，如果减1后进入数为0，则线程退出monitor，不再是该monitor所有者。
           其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。 
           
       总结：Synchronized的语义底层是通过一个monitor的对象来完成，
            wait/notify等方法也依赖于monitor对象，故只有在同步的块或者方法中能调用wait/notify等方法，
            否则会抛出java.lang.IllegalMonitorStateException的异常。
            
     同步方法：
       原理：不直接通过指令monitorenter和monitorexit来完成；
            常量池中多了ACC_SYNCHRONIZED标示符；
            方法调用时，先检查方法的ACC_SYNCHRONIZED访问标志是否被设置，
            如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor；
            本质上与上面没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。
            
               

    2.接口 Lock
      ReentrantLock是唯一实现了Lock接口的类；
      lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()用来获取锁；
      unLock()方法用来释放锁。
      
      原理：AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，
           当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，
           而那些等待执行的线程全部处于阻塞状态      
           
           lock源码：
           
           final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
           }
           
           当前线程会首先尝试获得锁而不是在队列中进行排队等候，
           这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来；
           对于刚来竞争的线程首先会通过CAS设置状态，如果设置成功那么直接获取锁，执行临界区的代码，
           反之调用acquire(1)进入同步队列中。
           如果已经存在Running线程，那么CAS肯定会失败，则新的竞争线程会通过CAS的方式被追加到队尾。
           
       总结：1、调用lock方法，会先进行cas操作看可否设置同步状态1成功，成功则执行临界区代码（抢锁成功）
            2、如果不成功获取同步状态，如果状态是0那么cas设置为1（没有有锁的其他线程）
            3、如果同步状态既不是0也不是自身线程持有会把当前线程构造成一个节点（其他线程有锁）
            4、把当前线程节点CAS的方式放入队列中，行为上线程阻塞，内部自旋获取状态（内部无限循环）
            5、线程释放锁，唤醒队列第一个节点，参与竞争。重复上述。

      

    3.lock与synchronized的区别
      Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
      synchronized不需要用户去手动释放锁，Lock则必须要用户去手动释放锁；
      synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁现象发生；
      Lock在发生异常时，如没有通过unLock()去释放锁，则可能造成死锁现象，一般在finally块中释放锁；
      Lock可以让等待锁的线程响应中断，synchronized不行（只能一直等待，不能中断等待的线程）；
      通过Lock可以知道有没有成功获取锁，synchronized不行；
      Lock可以提高多个线程进行读操作的效率；
      Lock可以读写分离（读与读不影响）；
      竞争资源不激烈，两者性能差不多，竞争资源非常激烈时，Lock的性能要远远优于synchronized。
      
    4.可重入锁
      如果锁具备可重入性，则称作为可重入锁；
      基于线程的分配，而不是基于方法调用的分配；
      synchronized和ReentrantLock都是可重入锁；
      如：线程调用synchronized修饰的method1（其实锁住的为类的实例对象），
         method1中调用synchronized修饰的method2时不用重新申请锁（基于线程分配锁）
         
    5.可中断锁
      可以相应中断的锁；
      synchronized不是可中断锁，Lock是可中断锁；
      如：中断等待线程
      
    6.公平锁
      公平锁即尽量以请求锁的顺序来获取锁;
      synchronized是非公平锁，ReentrantLock和ReentrantReadWriteLock默认非公平，可设置成公平；
      ReentrantLock lock = new ReentrantLock(true) 公平锁;
      
    7.读写锁
      读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁；
      线程之间的读操作不会发生冲突；
      ReadWriteLock。
      
    8.乐观锁和悲观锁
      悲观锁：别人想拿这个数据就会阻塞直到它拿到锁；
      乐观锁：不上锁，但在更新的时候会判断一下在此期间别人有没有去更新这个数据。
      
    9.CAS操作
      CAS操作是乐观锁；
      有的CAS操作都是Unsafe类来实现的，且都为native方法（java调用非java方法，java有局限性）；
      
      demo: CAS(V,E,N)
      V表示要更新的变量
      E表示预期值
      N表示新值
      如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做；
      
    10.volatile 关键字
       Java提供了volatile关键字来保证可见性；
       共享变量被volatile修饰，会保证修改的值会立即被更新到主存，其他线程读取时，会去主存中读取新值；
       普通共享变量被修改之后，什么时候被写入主存是不确定的；
       如，当线程2进行修改，会导致线程1工作内存中缓存变量无效，只能去主存读取（没有则等待）；
       
       对禁止指令重排序有一定作用，不能将在对volatile变量访问的语句放在其后面执行，前面也一样；
       
       原理：volatile关键字时，会多出一个lock前缀指令，相当于内存屏障。
         
      
![MacDown Screenshot](/assets/images/20170701155737036.png)

 原文：http://www.cnblogs.com/dolphin0520/p/3923167.html；
      https://www.cnblogs.com/paddix/p/5367116.html；
      https://blog.csdn.net/liyantianmin/article/details/54673109；
      https://blog.csdn.net/mmoren/article/details/79185862。
      
  
#### 2.集合类相关

    1.ConcurrentHashMap
    
      是一个Segment数组，Segment通过继承ReentrantLock加锁，所以每次锁住一个segment，
      保证每个Segment是线程安全的，就实现了全局的线程安全。
      
      concurrencyLevel：并行级别、并发数、Segment数。默认16，ConcurrentHashMap有16个Segments，
      理论上，这个时候，最多可以同时支持16个线程并发写，只要它们的操作分别分布在不同的Segment上。
      可在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。
      
      每个Segment类似HashMap，内部是由数组+链表组成的。不过它要保证线程安全。
      
      segment数组不能扩容，单个segment可以，扩容后，容量为原来的2倍。
      
      put:
      根据key的hash值找到相应的Segment（之后是Segment内部的put操作）；
      Segment内部put操作，加ReentrantLock锁；
      如果获得锁，直接put，没有则重试MAX_SCAN_RETRIES次，之后进入阻塞队列等待，知道获得锁；
      
      get:
      计算key的hash找到Segment;
      根据hash找到对应Segment中的链表（数据+链表）；
      顺着链表，==或者equals。
      
原文：https://javadoop.com/post/hashmap#Java8%20ConcurrentHashMap
      
#### 2.队列相关

    0.AQS（AbstractQueuedSynchronizer）
      多种多线程技术的本质原理所在，如ReentrantLock，CountDownLatch等；
      维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列
      （多线程争用资源被阻塞时会进入此队列，一个node代表一个线程）
      方法：
      isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
      tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
      tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
      tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
      tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。
      
      ReentrantLock，state初始化为0，表示未锁定状态。
      A线程lock()时，会调用tryAcquire()独占该锁并将state+1。
      此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止。
      释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。
      获取多少次就要释放多么次，这样才能保证state是能回到零态的。
      
      CountDownLatch，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。
      这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。
      所有子线程都执行完(state=0)，unpark()主线程，主线程就会从await()函数返回，继续执行。
      
      
原文：https://www.cnblogs.com/waterystone/p/4920797.html

#### 3.线程池
      
 
     
      
     
      
      
      
      
      

   
  
  
  
  