---
layout:         post
title:          Java多线程相关
subtitle:       常见多线程知识点整理
card-image:     https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1544886985001&di=6dabac2fd3dd7d2b0af391951190b93a&imgtype=0&src=http%3A%2F%2Fs1.51cto.com%2Foss%2F201802%2F27%2F164a32018df83046460958996918d890.jpg-wh_651x-s_1321967539.jpg
date:           2018-12-15 21:00:00
tags:           BigDataInterview
post-card-type: image
---

  无论是开dubbo接口、http接口，还是Java Web服务端开发，亦或者是各种中间件的开发；无并发，不Java，你们懂的；必须专门开一篇以示尊重，Java不息，更新不止。
  
#### 1.相关概念

    1.关键字 synchronized
    
      使用场景：
      
![MacDown Screenshot](/assets/images/2615789-08f16aeac7e0977d.png)

    原理：
    同步代码块：
      反编译可以看到monitorenter，monitorexit指令（相对于不加synchronized多出来）；
      原理：每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态，
           线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
           1、monitor的进入数为0，则该线程进入monitor，将进入数设置为1，该线程即为monitor的所有者。
           2、线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.
           3、其他线程占用monitor，则该线程进入阻塞状态，直到monitor进入数为0，再尝试monitor所有权。  
           
           执行monitorexit的线程必须是objectref所对应的monitor的所有者。
           执行后，monitor进入数减1，如果减1后进入数为0，则线程退出monitor，不再是该monitor所有者。
           其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。 
           
       总结：Synchronized的语义底层是通过一个monitor的对象来完成，
            wait/notify等方法也依赖于monitor对象，故只有在同步的块或者方法中能调用wait/notify等方法，
            否则会抛出java.lang.IllegalMonitorStateException的异常。
            
     同步方法：
       原理：不直接通过指令monitorenter和monitorexit来完成；
            常量池中多了ACC_SYNCHRONIZED标示符；
            方法调用时，先检查方法的ACC_SYNCHRONIZED访问标志是否被设置，
            如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor；
            本质上与上面没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。
            
               

    2.接口 Lock
      ReentrantLock是唯一实现了Lock接口的类；
      lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()用来获取锁；
      unLock()方法用来释放锁。
      
      原理：AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，
           当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，但正在执行的线程并不在队列中，
           而那些等待执行的线程全部处于阻塞状态      
           
           lock源码：
           
           final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
           }
           
           当前线程会首先尝试获得锁而不是在队列中进行排队等候，
           这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来；
           对于刚来竞争的线程首先会通过CAS设置状态，如果设置成功那么直接获取锁，执行临界区的代码，
           反之调用acquire(1)进入同步队列中。
           如果已经存在Running线程，那么CAS肯定会失败，则新的竞争线程会通过CAS的方式被追加到队尾。
           
       总结：1、调用lock方法，会先进行cas操作看可否设置同步状态1成功，成功则执行临界区代码（抢锁成功）
            2、如果不成功获取同步状态，如果状态是0那么cas设置为1（没有有锁的其他线程）
            3、如果同步状态既不是0也不是自身线程持有会把当前线程构造成一个节点（其他线程有锁）
            4、把当前线程节点CAS的方式放入队列中，行为上线程阻塞，内部自旋获取状态（内部无限循环）
            5、线程释放锁，唤醒队列第一个节点，参与竞争。重复上述。

      

    3.lock与synchronized的区别
      Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
      synchronized不需要用户去手动释放锁，Lock则必须要用户去手动释放锁；
      synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁现象发生；
      Lock在发生异常时，如没有通过unLock()去释放锁，则可能造成死锁现象，一般在finally块中释放锁；
      Lock可以让等待锁的线程响应中断，synchronized不行（只能一直等待，不能中断等待的线程）；
      通过Lock可以知道有没有成功获取锁，synchronized不行；
      Lock可以提高多个线程进行读操作的效率；
      Lock可以读写分离（读与读不影响）；
      竞争资源不激烈，两者性能差不多，竞争资源非常激烈时，Lock的性能要远远优于synchronized。
      
    4.可重入锁
      如果锁具备可重入性，则称作为可重入锁；
      基于线程的分配，而不是基于方法调用的分配；
      synchronized和ReentrantLock都是可重入锁；
      如：线程调用synchronized修饰的method1（其实锁住的为类的实例对象），
         method1中调用synchronized修饰的method2时不用重新申请锁（基于线程分配锁）
         
    5.可中断锁
      可以相应中断的锁；
      synchronized不是可中断锁，Lock是可中断锁；
      如：中断等待线程
      
    6.公平锁
      公平锁即尽量以请求锁的顺序来获取锁;
      synchronized是非公平锁，ReentrantLock和ReentrantReadWriteLock默认非公平，可设置成公平；
      ReentrantLock lock = new ReentrantLock(true) 公平锁;
      
    7.读写锁
      读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁；
      线程之间的读操作不会发生冲突；
      ReadWriteLock。
      
 原文：http://www.cnblogs.com/dolphin0520/p/3923167.html；
      https://www.cnblogs.com/paddix/p/5367116.html；
      https://blog.csdn.net/liyantianmin/article/details/54673109 
      
  
#### 2.集合类相关

    1.ConcurrentHashMap
    
      是一个Segment数组，Segment通过继承ReentrantLock加锁，所以每次锁住一个segment，
      保证每个Segment是线程安全的，就实现了全局的线程安全。
      
      concurrencyLevel：并行级别、并发数、Segment数。默认16，ConcurrentHashMap有16个Segments，
      理论上，这个时候，最多可以同时支持16个线程并发写，只要它们的操作分别分布在不同的Segment上。
      可在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。
      
      每个Segment类似HashMap，内部是由数组+链表组成的。不过它要保证线程安全。
      
      segment数组不能扩容，单个segment可以，扩容后，容量为原来的2倍。
      
      put:
      根据key的hash值找到相应的Segment（之后是Segment内部的put操作）；
      Segment内部put操作，加ReentrantLock锁；
      如果获得锁，直接put，没有则重试MAX_SCAN_RETRIES次，之后进入阻塞队列等待，知道获得锁；
      
      get:
      计算key的hash找到Segment;
      根据hash找到对应Segment中的链表（数据+链表）；
      顺着链表，==或者equals。
      
 原文：https://javadoop.com/post/hashmap#Java8%20ConcurrentHashMap
 
     
      
     
      
      
      
      
      

   
  
  
  
  